{"componentChunkName":"component---src-templates-blog-post-js","path":"/why-effects-shouldn't-lie-about-their-dependencies/","result":{"data":{"site":{"siteMetadata":{"title":"Aman's Blog","author":"Amandeep Singh"}},"markdownRemark":{"id":"2f7b6a4a-fa5c-565f-9729-616207c41fde","excerpt":"For a long time React developers have been inventing and sharing different patterns of reusing code logicâ€Šâ€”â€ŠHigher order component and render props are to nameâ€¦","html":"<p>For a long time React developers have been inventing and sharing different patterns of reusing code logicâ€Šâ€”â€Š<a href=\"https://reactjs.org/docs/higher-order-components.html\">Higher order component</a> and <a href=\"https://reactjs.org/docs/render-props.html\">render props</a> are to name a few. It was because <strong>React had no stateful primitive simpler than class component</strong>. Finally, the advent of <a href=\"https://reactjs.org/docs/hooks-intro.html\">hooks</a> into the React ecosystem has uprooted this problem and made code reusability a breeze. If you are interested to know why hooks were introduced, I have a written a separate in-depth article about it <a href=\"https://medium.com/@5066aman/how-to-write-90-cleaner-code-with-hooks-a3604116fb90?source=friends_link&#x26;sk=e3d0a1d284d45faa357638950421d520\">here</a>.</p>\n<p>In this article, I am going to talk about <em>useEffect</em> hook only and will share some of my learnings and few caveats associated with them. A few things we will discuss are:</p>\n<ol>\n<li>We will start off with an example of a using useEffect, which has a bug.</li>\n<li>Then, we will try to demystify the cause of this bug ğŸ˜€.</li>\n<li>And finally, weâ€™ll see how can we avoid these bugs and write effects which are easy to reason about.</li>\n</ol>\n<p>Before we go ahead, Iâ€™d like you to unlearn what you have been doing with the class componentâ€™s lifecycles. With hooks, we need a different mindset.</p>\n<blockquote>\n<p><em>In hooks land, functions are the kings.</em></p>\n</blockquote>\n<p>Enough of the background. Letâ€™s get started now.</p>\n<h3>A recap</h3>\n<p>Side effects are an indispensable part of any web applications. Fetching data, manually mutating DOM, and setting up subscription are all examples of side effects. The <em>useEffect</em> hook lets you perform side effects in your function component.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"> <span class=\"token comment\">// Inside your function component</span>\n <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token comment\">// some side effect code</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I have seen some of the developers assuming that itâ€™s always the same effect (anonymous function) which React calls after every render. But this is not the case.\nEvery time a re-render happens, we schedule a <strong>new effect</strong> replacing the <strong>previous effect</strong>. This is intentional and important as it makes the effect behaves more like a part of the render result. The key point to remember here is that each effect â€œbelongsâ€ to a particular render.</p>\n<blockquote>\n<p><em>Each effect â€œbelongsâ€ to a particular render.</em></p>\n</blockquote>\n<p>There is also an optional second argument to useEffect callâ€Šâ€”â€Šthe dependency array. This is a mechanism by which React knows when to skip running your effect if certain values havenâ€™t changed between re-renders.</p>\n<p>In the cases where effects require cleanup, we can optionally return a cleanup function. Keep in mind that React always calls this cleanup function before applying the next effect.</p>\n<blockquote>\n<p><em>React always clean up the previous effect before applying the next effect.</em></p>\n</blockquote>\n<p>With basics aside, letâ€™s now move onto the fun part.</p>\n<h3>1. A buggy effect</h3>\n<p>Here is an example code snippet demonstrating the usage of setInterval (a side effect) inside useEffect hook:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">CounterWithBug</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Count is </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token plain-text\"> </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Just by looking at this code, can you identify any bug?</p>\n<p>This code may look perfectly fine but our count value doesnâ€™t increment. Hereâ€™s the <a href=\"https://codesandbox.io/s/counterwithbug-sqn37\">demo</a> link if you wish to see that in action. You might be thinking that <em>setInterval</em> callback is calling the setter which should increment the count value after every 1 second. But this is not happening. What are we missing?</p>\n<h3>2. Demystifying the cause of the bug</h3>\n<p>We can definitely fix this issue with one small change and Iâ€™m sure most of you know how. But letâ€™s take a step back and try to understand why this behaviour exists.</p>\n<p>Every time when callback inside the <em>setInterval</em> calls the setter, React does a re-render. Doing so creates a new effect (function). But interestingly, as we have passed an empty <em>dependency array</em> [], which is a signal to React to skip applying this effect after the first render, it never gets invoked the second time.\nNow you might be wondering how does it make a difference: our setter is being called every time and so it should increment the <em>count</em> value. Right?</p>\n<p>This behaviour has nothing to do with React. Itâ€™s about how <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FClosures\">closures</a> work in JavaScript. In simple words, all functions in ECMAScript are closures since all of them at creation stage <strong>lexically</strong> captured the scope chain of itself and parent context. This is regardless of whether a function is <strong>activated</strong> later or not.</p>\n<p>Letâ€™s consider an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token comment\">// function is created here (not invoked yet)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">50</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// invocation happens here</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// will print 10</span></code></pre></div>\n<p>When <em>foo</em> is invoked, <em>10</em> will be printed, but not <em>50</em>. This is because when the <em>bar</em> is created earlier (function creation stage), <strong>x</strong> is stored statically into its scope chain and thatâ€™s what gets resolved when bar execution is activated later on.</p>\n<p>Letâ€™s consider one more example to strengthen our closure concept.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// prints 20 after a minimun time delay of 1 sec.</span></code></pre></div>\n<p>Even though the parent execution context is destroyed, callback inside the interval still manages to print the correct value of x after 1 second delay. This happens because of the <strong>closure</strong>. The inner function, statically at creation time, captures the variables defined in the parent scope.</p>\n<blockquote>\n<p>The inner function, statically at creation time, captures the variables defined in the parent scope.</p>\n</blockquote>\n<p>If you want to delve more into the concept of closures, Iâ€™ve written an article about it <a href=\"https://medium.com/@5066aman/lexical-environment-the-hidden-part-to-understand-closures-71d60efac0e0?source=friends_link&#x26;sk=7831bd115f13b3f667c877fb64aa4c9e\">here</a> too.</p>\n<p>Now taking this new knowledge along, letâ€™s visit our effect one more time from a different angle. Hereâ€™s the snippet again so that you donâ€™t have to scroll up:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">CounterWithBug</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// ğŸ›‘ missing the 'count' dependency</span></span>  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Count is </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token plain-text\"> </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>When the effect is executed after the first render, the anonymous callback inside setInterval <strong>statically</strong> captures the <em>count</em> value from its parent context. This happens at the <strong>creation stage</strong> and the value captured is 0. After a minimum delay of 1 sec, this callback is invoked, which in turn calls the setter with a new value of 1 (0 + 1). In response to this, React re-renders the component and you get to see the new <em>count</em> value of 1 in the UI.</p>\n<p>Now, as dependency array is empty, React will only create a new effect replacing the previous one, but <strong>never</strong> runs it. And as we just learned that React always cleans up the previous effects <strong>before</strong> applying the next effects, it will not bother running the cleanup in this case. Consequently, the initial interval never gets cleared out and our anonymous callback is still holding on to the count value of 0 into its scope chain. When the setter is called, the new value passed to it is always 1 (0 + 1). This is why the count value doesnâ€™t increment beyond 1.</p>\n<h3>3. Never lie about your effectâ€™s dependenciesâ€Šâ€”â€Ša few fixes</h3>\n<p>After successfully unveiling the root cause of the bug, now is the time to fix it. Itâ€™s always easy to find a cure when you know the exact source of the problem. The problem was that the interval captured the count value of 0 statically when the first render happened. So, the solution is to make the interval captured the latest count value every render. How can we make that possible? Can we take help from React?</p>\n<p>Yes! you guessed it rightâ€Šâ€”â€Š<em>the dependency array</em>. Whenever the value inside the dependency array changes, React cleans up the previous effect and applies the new one.</p>\n<h4>Fix 1: using â€˜countâ€™ as a dependency</h4>\n<p>In our buggy code example, we just need to pass the <strong>count</strong> variable as a dependency to fix the issue. Hereâ€™s the <a href=\"https://medium.com/r/?url=https%3A%2F%2Fcodesandbox.io%2Fs%2Fpeaceful-wave-9uudg\">demo link</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// âœ… passing 'count' as dependency</span></span>  <span class=\"token comment\">// will render the correct value of count</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Count is </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token plain-text\"> </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now with this little change, whenever the <em>count</em> value changes, React goes ahead and first call our cleanup mechanism which clears up the previous interval, and then sets a new interval by running the effect again. <strong>Bingo!!</strong> ğŸ‰</p>\n<p>In our code, the effect has a dependency over the <em>count</em> variable. So, it should also be inside the dependency array.</p>\n<p>So, the lesson is here that an effect should always be honest about its dependency. Every time this promise fails, a buggy code behaviour may appear.</p>\n<blockquote>\n<p>Effect should never lie about its dependency.</p>\n</blockquote>\n<h4>Fix 2: completely removing the dependency array</h4>\n<p>Another fix to resolve this issue is to completely remove the dependency array. When thereâ€™s no dependency array, React will make sure to follow the routine of clearing up the previous effect before running the new one. And now, of course, you know why does it make a difference ğŸ˜€</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// the following effect will run after the first render and after each update</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// âœ… No dependency array here.</span>\n  <span class=\"token comment\">// will render the correct value of count</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Count is </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token plain-text\"> </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Hereâ€™s the <a href=\"https://medium.com/r/?url=https%3A%2F%2Fcodesandbox.io%2Fs%2Fcountewithoutdeps-0ptoo\">demo</a> in action.</p>\n<h4>Fix 3: using â€˜updaterâ€™ function inside the setter</h4>\n<p>Now, if you have a sharp eye, you might have noticed that both aforementioned fixes are not very efficient. We are creating a new interval for each render. Our counter may run slowly as the browser has to clear up the previous interval before applying the new one. This could take some microseconds which could slowly add up and our counter would start to feel slow.</p>\n<p>So, can we just set our interval once and only clear it when our component unmounts? The only way to do this is by passing an empty array. Right? But then we are again hitting the same issue as we saw above. We have to pass the <em>count</em> variable again.</p>\n<p>Well, to solve this conundrum, we will follow the same rule of thumbâ€Šâ€”â€Šdonâ€™t lie about your effectâ€™s dependency. Check out the <a href=\"https://medium.com/r/?url=https%3A%2F%2Fcodesandbox.io%2Fs%2Fcounterusingstateupdater-5ynwv\">demo</a> here.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// âœ… No more dependency on `count` variable outside</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></span>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Count is : </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we are using the updater function inside our setter function which doesnâ€™t depend on <em>count</em> variable outside. Doing so, allow us to use an <strong>empty</strong> dependency array. We are not lying to React about our effectâ€™s dependency. This is a moment of proud ğŸ‘.</p>\n<h4>Fix 4: â€œuseRefâ€ to the rescue</h4>\n<p>Before wrapping it up, I want to show you one more solution to this issue. This solution is based around using another hook called <a href=\"https://medium.com/r/?url=https%3A%2F%2Freactjs.org%2Fdocs%2Fhooks-reference.html%23useref\">useRef</a>.</p>\n<p>I donâ€™t want to go into much details of explaining how <em>useRef</em> works. But I think of them as a box where you can place any value. They are more like <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%23Instance_properties\">instance properties</a> in JavaScript classes. The interesting fact is React <strong>preserves</strong> the value of a returned object from <em>useRef</em> across different renders.</p>\n<p>Letâ€™s visit our code example again the last time:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">CounterUsingRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// âœ… putting fresh count into the latestCount</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> latestCount <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// âœ… make sure current always point to fresh value of count</span></span><span class=\"gatsby-highlight-code-line\">    latestCount<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> count</span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></span>  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>latestCount<span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Counter with useRef: </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h3</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again weâ€™ve kept our promise of <strong>not lying</strong> about our dependency. Our effect is no more <em>count</em> variable dependent.</p>\n<p>Even though the interval is still statically capturing the <em>latestCount</em> object (as it does in the case of the first buggy example), React makes sure the <strong>mutable</strong> <em>current</em> always gets the fresh count value. ğŸ™‚</p>\n<p>Hereâ€™s the <a href=\"https://medium.com/r/?url=https%3A%2F%2Fcodesandbox.io%2Fs%2Fcounterusingref-ekdzd\">demo</a> for above code snippet if youâ€™re interested.</p>\n<h3>Conclusion</h3>\n<p>Letâ€™s recap what we have just learned:</p>\n<ol>\n<li>The <strong>function</strong> passed to <em>useEffect</em> is going to be <strong>different</strong> on every render and this behaviour is intentional.</li>\n<li>Every time we re-render, we schedule a <strong>new</strong> effect, replacing the <strong>previous</strong> one.</li>\n<li>All functions, at the <strong>creation stage</strong>, statically captures the variable defined in the <strong>parent scope</strong>.</li>\n<li>We should <strong>never lie</strong> to React about our effectâ€™s dependencies.</li>\n</ol>\n<hr>\n<p>I hope this article was interesting to read and has helped you understand why dependency array plays an important role in our effects. Consequently, I strongly recommend installing an ESLint plugin called <a href=\"http://ks%28https//www.npmjs.com/package/eslint-plugin-react-hooks\"><em>eslint-plugin-react-hook</em></a> that enforces this rule.</p>\n<p>Hereâ€™s a single <a href=\"https://codesandbox.io/s/setintervalwithuseeffect-vbneb\">link</a> of all the demos combined in one file. Keep an eye on the second fix and see how it is slower ğŸ¢ than the last two fixes.</p>\n<p>Now go ahead and share this knowledge with others ğŸ™‚.</p>","frontmatter":{"title":"Why Effects shouldn't lie about their dependencies","date":"July 01, 2019","description":"Effects play a crucial part in your application. Understanding why its important to pass correct dependencies in your `useEffect` hook can help you avoid bugs."}}},"pageContext":{"slug":"/why-effects-shouldn't-lie-about-their-dependencies/","previous":{"fields":{"slug":"/hidden-gems-of-debugging/"},"frontmatter":{"title":"Hidden gems of debugging"}},"next":{"fields":{"slug":"/what's-the-deal-with-Object.prototype.hasOwnProperty.call()/"},"frontmatter":{"title":"What's the deal with Object.prototype.hasOwnProperty.call()?"}}}},"staticQueryHashes":["426816048","63159454"]}