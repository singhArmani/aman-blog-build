{"componentChunkName":"component---src-templates-blog-post-js","path":"/git-interactive-enhance-your-work-productiviy-by-10X/","result":{"data":{"site":{"siteMetadata":{"title":"Aman's Blog","author":"Amandeep Singh"}},"markdownRemark":{"id":"a2a71760-b545-5948-98c0-1881f77d2636","excerpt":"Git has a plethora of commands at your disposal. But we often end up using only a handful of those in our daily git workflow. The  and  are one of thoseâ€¦","html":"<p><strong>Git</strong> has a plethora of commands at your disposal. But we often end up using only a handful of those in our daily git workflow. The <code class=\"language-text\">git add</code> and <code class=\"language-text\">git checkout</code> are one of those indispensable commands: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// stage the modified content of the working directory</span>\n<span class=\"gatsby-highlight-code-line\">git add <span class=\"token punctuation\">.</span></span>\n<span class=\"token comment\">// for checking out to other branches</span>\n<span class=\"gatsby-highlight-code-line\">git checkout <span class=\"token operator\">&lt;</span>branch<span class=\"token operator\">-</span>name<span class=\"token operator\">></span></span></code></pre></div>\n<p>But, I have often seen devs not leveraging these commands to their full power. The aforementioned usages are often enough to get the job done. Moreover, our mind is so comfortable in using them that we donâ€™t want to explore what rest they have to offer.  </p>\n<p>This article is my attempt to change how you think about these two commands. Welcome to the world of <strong>git interactive</strong>.</p>\n<h3>1. Interactive Staging</h3>\n<blockquote>\n<p><strong>git add -p</strong></p>\n</blockquote>\n<h4>Explanation</h4>\n<p>This command gives you the flexibility of selecting <strong>granular changes</strong>, and mark them accordingly to go into your <strong>staging area</strong>. Instead of adding a complete file, You can stage only desired hunks of diffs from it and leave the rest. For e.g, If you have made two changes in your tracked file <code class=\"language-text\">README.md</code> , you can stage one of them and not the other. </p>\n<h4>Use Cases</h4>\n<h5>Add smaller commits</h5>\n<p>We should strive to keep our commits smaller. A commit subject should be enough to justify your reason for the specified change.</p>\n<p>In those scenarios, where you have gone too far and refactored a huge bunch of code, <code class=\"language-text\">git add -p</code> is your best bet. It helps you to add small and isolated changes and make them ready for a commit. You can re-visit and select more hunks to be part of the subsequent commits. </p>\n<h5>Handy while debugging and refactoring</h5>\n<p>While diagnosing an issue, you might have sprinkled a whole bunch of console.log statements. Doing so, you might have refactored a few lines of code that you might want to keep for future commits. </p>\n<p>You can smartly use <code class=\"language-text\">git add -p</code> to cherry-pick those useful lines of code and create a commit out of that. This will leave the log statements in your working directory, which you can safely discard later on. </p>\n<h3>2. Interactive checkout</h3>\n<blockquote>\n<p><strong>git checkout -p</strong></p>\n</blockquote>\n<h4>Explanation</h4>\n<p>This command allows you to <strong>discard hunks</strong> interactively from your working directory. In other words, it does the opposite of interactive staging. Instead of discarding all the changes in a file, you can choose which part of the file you want to remove and keep the rest ðŸš€. </p>\n<h4>Use Cases</h4>\n<h5>Keeping your working directory clean</h5>\n<p>If you have been brainstorming about an idea, and have quickly scribbled a few lines to code. You can invoke this command and interactivity remove irrelevant code from your working directory, leaving important bits to become part of the staging area. </p>\n<h5>Handy while debugging</h5>\n<p>The same use case as we have for interactive staging, but works in reverse order. Instead of cherry-picking useful bits, you can discard the unnecessary log statements and leave the important work for future staging.</p>\n<hr>\n<p>This is all for now. To learn more about git tools and command, I highly recommend reading this book <a href=\"https://git-scm.com/book/en/v2\">here</a>. â€¨Now go ahead and give these commands a try.</p>","frontmatter":{"title":"Git Interactiveâ€”enhance your work productivity by 10X","date":"August 01, 2020","description":"It's time to supercharge your git tooling. We will go beyond your normal git add and git checkout command, and showcase their interactive counterparts."}}},"pageContext":{"slug":"/git-interactive-enhance-your-work-productiviy-by-10X/","previous":{"fields":{"slug":"/what's-the-deal-with-Object.prototype.hasOwnProperty.call()/"},"frontmatter":{"title":"What's the deal with Object.prototype.hasOwnProperty.call()?"}},"next":{"fields":{"slug":"/how-to-smartly-cleanup-your-commit-history-using-git/"},"frontmatter":{"title":"How to smartly cleanup your commit history using git reset?"}}}},"staticQueryHashes":["426816048","63159454"]}